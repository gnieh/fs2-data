<!DOCTYPE HTML>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>fs2-data - JSON</title>
    <link rel="stylesheet" href="/css/stylesheet.css">
    <link rel="stylesheet" href="/css/syntax.css">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <link type="text/css" rel="stylesheet" href="/css/materialize.min.css" media="screen,projection"/>
    <style>body{font-family: overpass, sans-serif; }</style>

    <meta name="generator" content="Nanoc 4.12.10">
  </head>
  <body>
    <header>
        <nav class="nav-extended red darken-2">
          <a href="#!" class="brand-logo right">fs2-data</a>
          <a href="#" data-target="collapsed" class="sidenav-trigger"><i class="material-icons">menu</i></a>
          <div class="nav-wrapper">
            <ul id="nav-mobile" class="left hide-on-med-and-down">
              <li><a href="/">Home</a></li>
              <li><a href="/documentation/">Documentation</a></li>
              <li><a href="/api/">Scaladoc</a></li>
              <li><a href="https://github.com/gnieh/fs2-data">Github</a></li>
            </ul>
          </div>
          
          
          <div class="nav-content">
            <ul class="tabs tabs-transparent">
              
              
              <li class="tab active"><a href="/documentation/json/">JSON</a></li>
              
              
              
              <li class="tab"><a href="/documentation/json/libraries/">JSON Libraries</a></li>
              
              
              
              <li class="tab"><a href="/documentation/json/jsonpath/">JSONPath</a></li>
              
              
              
              <li class="tab"><a href="/documentation/json/patches/">JSON Patch</a></li>
              
              
              
              <li class="tab"><a href="/documentation/json/interpolators/">Interpolators</a></li>
              
              
            </ul>
          </div>
          
        </nav>

    </header>

    <ul class="sidenav" id="collapsed">
      <li><a href="/">Home</a></li>
      <li><a href="/documentation/">Documentation</a></li>
      <li><a href="/api/">Scaladoc</a></li>
      <li><a href="https://github.com/gnieh/fs2-data">Github</a></li>
    </ul>

    
    <div class="fixed-action-btn tooltipped" data-position="left" data-tooltip="Edit this page">
      <a class="btn-floating btn-large blue darken-2" href="https://github.com/gnieh/fs2-data/edit/main/documentation/docs/json/index.md" target="_blank">
        <i class="large material-icons">mode_edit</i>
      </a>
    </div>
    

    <main>
      <div class="container">
        <p>Module: <a href="https://mvnrepository.com/artifact/org.gnieh/fs2-data-json_2.13"><img src="https://img.shields.io/maven-central/v/org.gnieh/fs2-data-json_2.13.svg" alt="Maven Central" /></a></p>

<p>The <code>fs2-data-json</code> module provides tools to parse, query and transform JSON data in a streaming manner.</p>

<p>This page covers the following topics:</p>
<ul id="markdown-toc">
  <li><a href="#json-parsing" id="markdown-toc-json-parsing">JSON parsing</a></li>
  <li><a href="#selectors" id="markdown-toc-selectors">Selectors</a>    <ul>
      <li><a href="#parsing-a-string-using-the-selector-syntax" id="markdown-toc-parsing-a-string-using-the-selector-syntax">Parsing a string using the selector syntax</a></li>
      <li><a href="#using-the-selector-dsl" id="markdown-toc-using-the-selector-dsl">Using the selector DSL</a></li>
    </ul>
  </li>
  <li><a href="#ast-builder-and-tokenizer" id="markdown-toc-ast-builder-and-tokenizer">AST builder and tokenizer</a></li>
  <li><a href="#serializers-and-deserializers" id="markdown-toc-serializers-and-deserializers">Serializers and deserializers</a></li>
  <li><a href="#json-renderers" id="markdown-toc-json-renderers">JSON Renderers</a></li>
  <li><a href="#generating-json-streams" id="markdown-toc-generating-json-streams">Generating JSON streams</a></li>
</ul>

<h3 id="json-parsing">JSON parsing</h3>

<p>To create a stream of JSON tokens from an input stream, use the <code>tokens</code> pipe in <code>fs2.data.json</code> package. This pipe accepts a stream of characters and returns a stream of JSON tokens. This produces a stream of structurally valid tokens forming the JSON documents.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.effect._</span>
<span class="k">import</span> <span class="nn">cats.syntax.all._</span>

<span class="k">import</span> <span class="nn">fs2._</span>
<span class="k">import</span> <span class="nn">fs2.data.json._</span>

<span class="k">val</span> <span class="nv">input</span> <span class="k">=</span> <span class="s">"""{
              |  "field1": 0,
              |  "field2": "test",
              |  "field3": [1, 2, 3]
              |}
              |{
              |  "field1": 2,
              |  "field3": []
              |}"""</span><span class="o">.</span><span class="py">stripMargin</span>
<span class="c1">// input: String = """{</span>
<span class="c1">//   "field1": 0,</span>
<span class="c1">//   "field2": "test",</span>
<span class="c1">//   "field3": [1, 2, 3]</span>
<span class="c1">// }</span>
<span class="c1">// {</span>
<span class="c1">//   "field1": 2,</span>
<span class="c1">//   "field3": []</span>
<span class="c1">// }"""</span>

<span class="k">val</span> <span class="nv">stream</span> <span class="k">=</span> <span class="nv">Stream</span><span class="o">.</span><span class="py">emit</span><span class="o">(</span><span class="n">input</span><span class="o">).</span><span class="py">through</span><span class="o">(</span><span class="n">tokens</span><span class="o">[</span><span class="kt">Fallible</span>, <span class="kt">String</span><span class="o">])</span>
<span class="c1">// stream: Stream[[A]Fallible[A], Token] = Stream(..)</span>
<span class="nv">stream</span><span class="o">.</span><span class="py">compile</span><span class="o">.</span><span class="py">toList</span>
<span class="c1">// res0: Either[Throwable, List[Token]] = Right(</span>
<span class="c1">//   value = List(</span>
<span class="c1">//     StartObject,</span>
<span class="c1">//     Key(value = "field1"),</span>
<span class="c1">//     NumberValue(value = "0"),</span>
<span class="c1">//     Key(value = "field2"),</span>
<span class="c1">//     StringValue(value = "test"),</span>
<span class="c1">//     Key(value = "field3"),</span>
<span class="c1">//     StartArray,</span>
<span class="c1">//     NumberValue(value = "1"),</span>
<span class="c1">//     NumberValue(value = "2"),</span>
<span class="c1">//     NumberValue(value = "3"),</span>
<span class="c1">//     EndArray,</span>
<span class="c1">//     EndObject,</span>
<span class="c1">//     StartObject,</span>
<span class="c1">//     Key(value = "field1"),</span>
<span class="c1">//     NumberValue(value = "2"),</span>
<span class="c1">//     Key(value = "field3"),</span>
<span class="c1">//     StartArray,</span>
<span class="c1">//     EndArray,</span>
<span class="c1">//     EndObject</span>
<span class="c1">//   )</span>
<span class="c1">// )</span>
</code></pre></div></div>

<p>The pipe validates the JSON structure while parsing. It reads all the json values in the input stream and emits tokens as they are available.</p>

<h3 id="selectors">Selectors</h3>

<p>Selectors can be used to select a subset of a JSON token stream. There are several ways to create selectors:</p>
<ul>
  <li>build the selector using the constructors, which can be quite verbose and cumbersome;</li>
  <li>parse a string with the selector syntax;</li>
  <li>use the selector DSL.</li>
</ul>

<h4 id="parsing-a-string-using-the-selector-syntax">Parsing a string using the selector syntax</h4>

<p>For instance, to select and enumerate elements that are in the <code>field3</code> array, you can create this selector. Only the tokens describing the values in <code>field3</code> will be emitted as a result.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="kt">ThrowableEither</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Either</span><span class="o">[</span><span class="kt">Throwable</span>, <span class="kt">T</span><span class="o">]</span>

<span class="k">val</span> <span class="nv">selector</span> <span class="k">=</span> <span class="s">".field3.[]"</span><span class="o">.</span><span class="py">parseSelector</span><span class="o">[</span><span class="kt">ThrowableEither</span><span class="o">].</span><span class="py">toTry</span><span class="o">.</span><span class="py">get</span>
<span class="c1">// selector: Selector = PipeSelector(</span>
<span class="c1">//   left = NameSelector(</span>
<span class="c1">//     pred = Single(name = "field3"),</span>
<span class="c1">//     strict = true,</span>
<span class="c1">//     mandatory = false</span>
<span class="c1">//   ),</span>
<span class="c1">//   right = IteratorSelector(strict = true)</span>
<span class="c1">// )</span>
</code></pre></div></div>

<p>The <code>parseSelector</code> method implicitly comes from the <code>import fs2.data.json._</code> and wraps the result in anything that has an <a href="https://typelevel.org/cats/api/cats/MonadError.html"><code>MonadError</code> with error type <code>Throwable</code></a> to catch potential parsing errors. If you prefer not to have this wrapping and donâ€™t mind an extra dependency, you can have a look at <a href="/documentation/json/libraries">the interpolator</a>.</p>

<p>The filter syntax is as follows:</p>
<ul>
  <li><code>.</code> selects the root values, it is basically the identity filter.</li>
  <li><code>.f</code> selects the field named <code>f</code> in objects. It fails if the value it is applied to is not a JSON object.
    <ul>
      <li><code>f</code> must be a valid Java identifier, meaning it has to respect this regular expression: <code>[a-zA-Z_][a-zA-Z0-9_]*</code>. If you wish to select a field that doesnâ€™t respect this regular expression, you can use the syntax <code>.["my non-identifier field"]</code> described below.</li>
      <li>name <code>f</code> can be immediately followed by a <code>!</code> to mark it as mandatory. Stream will fail if the end of the object the selector is applied to is reached and the field was not present in the object.</li>
    </ul>
  </li>
  <li><code>.f?</code> is similar to <code>.f</code> but doesnâ€™t fail in case the value it is applied to is not a JSON object.
    <ul>
      <li>both <code>!</code> and <code>?</code> can be combined as <code>.f!?</code> to indicate that if the value it is applied to is a JSON object, then the field must be in it.</li>
    </ul>
  </li>
  <li><code>.["f1", "f2", ..., "fn"]</code> selects only fields <code>f1</code> to <code>fn</code> in objects. It fails if the value it is applied to is not an object.
    <ul>
      <li>the field list can be immediately followed by a <code>!</code> to mark all fields as mandatory. Stream will fail if the end of the object the selector is applied to is reached and at least one field in the list was not present in the object.</li>
    </ul>
  </li>
  <li><code>.["f1", "f2", ..., "fn"]?</code> is similar to <code>.["f1", "f2", ..., "fn"]</code> but doesnâ€™t fail if the value it is applied to is not an object.
    <ul>
      <li>both <code>!</code> and <code>?</code> can be combined as <code>.["f1", "f2", ..., "fn"]!?</code> to indicate that if the value it is applied to is a JSON object, then all the specified fields must be in it.</li>
    </ul>
  </li>
  <li><code>.[id1, idx2, ..., idxn]</code> selects only elements <code>idx1</code>, â€¦, <code>idxn</code> in arrays. It fails if the value it is applied to is not an array.</li>
  <li><code>.[idx1, idx2, ..., idxn]?</code> is similar to <code>.[idx1, idx2, ..., idxn]</code> but doesnâ€™t fail if the value it is applied to is not an array.</li>
  <li><code>.[idx1:idx2]</code> selects only elements between <code>idx1</code> (inclusive) and <code>idx2</code> (exclusive) in arrays. It fails if the value it is applied to is not an array.</li>
  <li><code>.[idx1:idx2]?</code> is similar to <code>.[idx1:idx2]</code> but doesnâ€™t fail if the value it is applied to is not an array.</li>
  <li><code>.[]</code> selects and enumerates elements from arrays or objects. It fails if the value it is applied to is not an array or an object.</li>
  <li><code>.[]?</code> is similar as <code>.[]</code> but doesnâ€™t fail if the value it is applied to is neither an array nor an object.</li>
  <li><code>sel1 sel2</code> applies selector <code>sel1</code> to the root value, and selector <code>sel2</code> to each selected value.</li>
</ul>

<h4 id="using-the-selector-dsl">Using the selector DSL</h4>

<p>The selector DSL is a nice way to describe selectors without using any string parsing. They also allow for programmatically building selectors.<br />
The DSL resides within the <code>fs2.data.json.selector</code> package, and you start a selector using the <code>root</code> builder.<br />
The selector above can be written like this with the DSL:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">fs2.data.json.selector._</span>

<span class="k">val</span> <span class="nv">selectorFromDsl</span> <span class="k">=</span> <span class="nv">root</span><span class="o">.</span><span class="py">field</span><span class="o">(</span><span class="s">"field3"</span><span class="o">).</span><span class="py">iterate</span><span class="o">.</span><span class="py">compile</span>
<span class="c1">// selectorFromDsl: Selector = PipeSelector(</span>
<span class="c1">//   left = NameSelector(</span>
<span class="c1">//     pred = Single(name = "field3"),</span>
<span class="c1">//     strict = true,</span>
<span class="c1">//     mandatory = false</span>
<span class="c1">//   ),</span>
<span class="c1">//   right = IteratorSelector(strict = true)</span>
<span class="c1">// )</span>
</code></pre></div></div>

<p>The <code>.compile</code> in the end transforms the previous selector builder from the DSL into the final selector. Builders are safe to reuse, re-compose and compile several times.</p>

<p>You can express the same selectors as with the syntax described above. For instance to make the field mandatory and the iteration lenient you can do:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">selectorFromDsl</span> <span class="k">=</span> <span class="nv">root</span><span class="o">.</span><span class="py">field</span><span class="o">(</span><span class="s">"field3"</span><span class="o">).!.</span><span class="py">iterate</span><span class="o">.?.</span><span class="py">compile</span>
<span class="c1">// selectorFromDsl: Selector = PipeSelector(</span>
<span class="c1">//   left = NameSelector(</span>
<span class="c1">//     pred = Single(name = "field3"),</span>
<span class="c1">//     strict = true,</span>
<span class="c1">//     mandatory = true</span>
<span class="c1">//   ),</span>
<span class="c1">//   right = IteratorSelector(strict = false)</span>
<span class="c1">// )</span>
</code></pre></div></div>

<p>The DSL is typesafe, so that you cannot write invalid selectors. Any attempt to do so results in a compilation error.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// array index selection cannot be made mandatory</span>
<span class="nv">root</span><span class="o">.</span><span class="py">index</span><span class="o">(</span><span class="mi">1</span><span class="o">).!</span>
<span class="c1">// error: Only not yet mandatory field selectors can be made mandatory</span>
<span class="c1">// root.index(1).!</span>
<span class="c1">// ^^^^^^^^^^^^^^^</span>
</code></pre></div></div>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// you cannot use the same flag twice</span>
<span class="nv">root</span><span class="o">.</span><span class="py">index</span><span class="o">(</span><span class="mi">1</span><span class="o">).?.?</span>
<span class="c1">// error: There seems to be no way to make this selector lenient. Is it already?</span>
<span class="c1">// root.index(1).!</span>
<span class="c1">// ^^^^^</span>
</code></pre></div></div>

<h3 id="ast-builder-and-tokenizer">AST builder and tokenizer</h3>

<p>To handle Json ASTs, you can use the types and pipes available in the <code>fs2.data.json.ast</code> package.</p>

<p>JSON ASTs can be built if you provide an implicit <a href="/api/fs2/data/json/ast/Builder.html"><code>Builder[Json]</code></a> to the <code>values</code> pipe. The <code>Builder[Json]</code> typeclass describes how JSON ASTs of type <code>Json</code> are built from streams.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">ast._</span>

<span class="k">trait</span> <span class="nc">SomeJsonType</span>

<span class="k">implicit</span> <span class="k">val</span> <span class="nv">builder</span><span class="k">:</span> <span class="kt">Builder</span><span class="o">[</span><span class="kt">SomeJsonType</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span>
<span class="nv">stream</span><span class="o">.</span><span class="py">through</span><span class="o">(</span><span class="n">values</span><span class="o">[</span><span class="kt">Fallible</span>, <span class="kt">SomeJsonType</span><span class="o">])</span>
</code></pre></div></div>

<p>The <code>asts</code> stream emits all top-level JSON values parsed, in our example, the two objects are emitted.</p>

<p>If you provide an implicit <a href="/api/fs2/data/json/ast/Tokenizer.html"><code>Tokenizer[Json]</code></a>, which describes how a JSON AST is transformed into JSON tokens, you can apply transformations to the JSON stream. For instance, you can apply a function <code>fun</code> to all values in the <code>fields3</code> array by using this code:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">ast._</span>

<span class="k">trait</span> <span class="nc">SomeJsonType</span>

<span class="k">implicit</span> <span class="k">val</span> <span class="nv">builder</span><span class="k">:</span> <span class="kt">Builder</span><span class="o">[</span><span class="kt">SomeJsonType</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span>
<span class="k">implicit</span> <span class="k">val</span> <span class="nv">tokenizer</span><span class="k">:</span> <span class="kt">Tokenizer</span><span class="o">[</span><span class="kt">SomeJsonType</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span>

<span class="k">def</span> <span class="nf">fun</span><span class="o">(</span><span class="n">json</span><span class="k">:</span> <span class="kt">SomeJsonType</span><span class="o">)</span><span class="k">:</span> <span class="kt">SomeJsonType</span> <span class="o">=</span> <span class="o">???</span>

<span class="nv">stream</span><span class="o">.</span><span class="py">through</span><span class="o">(</span><span class="n">transform</span><span class="o">[</span><span class="kt">Fallible</span>, <span class="kt">SomeJsonType</span><span class="o">](</span><span class="n">selector</span><span class="o">,</span> <span class="n">fun</span><span class="o">))</span>
</code></pre></div></div>
<p>For concrete examples of provided <code>Builder</code>s and <code>Tokenizer</code>s, please refer to <a href="/documentation/json/libraries">the JSON library binding modules documentation</a>.</p>

<p>Sometimes you would like to delete some Json values from the input stream, based o some predicate at a given path, and keep the rest untouched. In this case, you can use the <code>transformOpt</code> pipe, and return <code>None</code> for values you want to remove from the stream.</p>

<h3 id="serializers-and-deserializers">Serializers and deserializers</h3>

<p>To handle Json (de)serialized values, you can use the types and pipes available in the <code>fs2.data.json.codec</code> package.</p>

<p>Values can be automatically deserialized from a stream of JSON tokens by providing a <a href="/api/fs2/data/json/codec/Deserializer.html"><code>Deserializer[T]</code></a>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">codec._</span>

<span class="k">implicit</span> <span class="k">val</span> <span class="nv">deserializer</span><span class="k">:</span> <span class="kt">Deserializer</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span>
<span class="nv">stream</span><span class="o">.</span><span class="py">through</span><span class="o">(</span><span class="n">deserialize</span><span class="o">[</span><span class="kt">Fallible</span>, <span class="kt">Int</span><span class="o">])</span>
</code></pre></div></div>

<p>You can also serialize a stream of values by providing a <a href="/api/fs2/data/json/codec/Serializer.html"><code>Serializer[T]</code></a>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">codec._</span>

<span class="k">implicit</span> <span class="k">val</span> <span class="nv">serializer</span><span class="k">:</span> <span class="kt">Serializer</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span>

<span class="nc">Stream</span><span class="o">(</span><span class="s">"a"</span><span class="o">,</span> <span class="s">"b"</span><span class="o">,</span> <span class="s">"c"</span><span class="o">).</span><span class="py">through</span><span class="o">(</span><span class="n">serialize</span><span class="o">)</span>
</code></pre></div></div>

<p>The <code>codec</code> package also contains various transformation pipes, acting directly on values. Please refer to the <a href="/api/fs2/data/json/codec/">package API documentation</a> for more details.</p>

<p>For concrete examples of provided <code>Deserializer</code>s and <code>Serializer</code>s, please refer to <a href="/documentation/json/libraries">the JSON library binding modules documentation</a>.</p>

<h3 id="json-renderers">JSON Renderers</h3>

<p>Once you got a JSON token stream, selected and transformed what you needed in it, you can then write the resulting token stream to some storage. This can be achieved using renderers.</p>

<p>For instance, letâ€™s say you want to write the resulting JSON stream to a file in compact form (i.e. with no space or new lines), you can do:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">fs2.io.file.</span><span class="o">{</span><span class="nc">Files</span><span class="o">,</span> <span class="nc">Flags</span><span class="o">,</span> <span class="nc">Path</span><span class="o">}</span>

<span class="n">stream</span>
  <span class="o">.</span><span class="py">through</span><span class="o">(</span><span class="nv">render</span><span class="o">.</span><span class="py">compact</span><span class="o">)</span>
  <span class="o">.</span><span class="py">through</span><span class="o">(</span><span class="nv">text</span><span class="o">.</span><span class="py">utf8</span><span class="o">.</span><span class="py">encode</span><span class="o">)</span>
  <span class="o">.</span><span class="py">lift</span><span class="o">[</span><span class="kt">IO</span><span class="o">]</span>
  <span class="o">.</span><span class="py">through</span><span class="o">(</span><span class="nc">Files</span><span class="o">[</span><span class="kt">IO</span><span class="o">].</span><span class="py">writeAll</span><span class="o">(</span><span class="nc">Path</span><span class="o">(</span><span class="s">"/some/path/to/file.json"</span><span class="o">),</span> <span class="nv">Flags</span><span class="o">.</span><span class="py">Write</span><span class="o">))</span>
  <span class="o">.</span><span class="py">compile</span>
  <span class="o">.</span><span class="py">drain</span>
</code></pre></div></div>

<p>There exists also a <code>pretty()</code> renderer, that indents inner elements by the given indent string.</p>

<p>If you are interested in the String rendering as a value, the library also provides <a href="https://oss.sonatype.org/service/local/repositories/releases/archive/co/fs2/fs2-core_2.13/2.3.0/fs2-core_2.13-2.3.0-javadoc.jar/!/fs2/Collector.html"><code>Collector</code>s</a>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">stream</span><span class="o">.</span><span class="py">compile</span><span class="o">.</span><span class="py">to</span><span class="o">(</span><span class="nv">collector</span><span class="o">.</span><span class="py">compact</span><span class="o">)</span>
<span class="c1">// res8: Either[Throwable, collector.compact.Out] = Right(</span>
<span class="c1">//   value = "{\"field1\":0,\"field2\":\"test\",\"field3\":[1,2,3]}{\"field1\":2,\"field3\":[]}"</span>
<span class="c1">// )</span>

<span class="c1">// default indentation is 2 spaces</span>
<span class="nv">stream</span><span class="o">.</span><span class="py">compile</span><span class="o">.</span><span class="py">to</span><span class="o">(</span><span class="nv">collector</span><span class="o">.</span><span class="py">pretty</span><span class="o">())</span>
<span class="c1">// res9: Either[Throwable, String] = Right(</span>
<span class="c1">//   value = """{</span>
<span class="c1">//   "field1": 0,</span>
<span class="c1">//   "field2": "test",</span>
<span class="c1">//   "field3": [</span>
<span class="c1">//     1,</span>
<span class="c1">//     2,</span>
<span class="c1">//     3</span>
<span class="c1">//   ]</span>
<span class="c1">// }</span>
<span class="c1">// {</span>
<span class="c1">//   "field1": 2,</span>
<span class="c1">//   "field3": []</span>
<span class="c1">// }"""</span>
<span class="c1">// )</span>
<span class="c1">// if you are more into tabs (or any other indentation size) you can change the indentation string</span>
<span class="nv">stream</span><span class="o">.</span><span class="py">compile</span><span class="o">.</span><span class="py">to</span><span class="o">(</span><span class="nv">collector</span><span class="o">.</span><span class="py">pretty</span><span class="o">(</span><span class="s">"\t"</span><span class="o">))</span>
<span class="c1">// res10: Either[Throwable, String] = Right(</span>
<span class="c1">//   value = """{</span>
<span class="c1">// 	"field1": 0,</span>
<span class="c1">// 	"field2": "test",</span>
<span class="c1">// 	"field3": [</span>
<span class="c1">// 		1,</span>
<span class="c1">// 		2,</span>
<span class="c1">// 		3</span>
<span class="c1">// 	]</span>
<span class="c1">// }</span>
<span class="c1">// {</span>
<span class="c1">// 	"field1": 2,</span>
<span class="c1">// 	"field3": []</span>
<span class="c1">// }"""</span>
<span class="c1">// )</span>
</code></pre></div></div>

<h3 id="generating-json-streams">Generating JSON streams</h3>

<p>Another use case of the library can be to generate a JSON token stream. This comes in handy if you are developing a web service that returns some big JSON in chunks.</p>

<p>To this end you can use the pipes in <code>wrap</code> which allow you to wrap a stream into an object structure.</p>

<p>For instance imagine you have a store of events which can return a stream of events, and you have a way to serialize the events into JSON.</p>
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">Event</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">CreateCounter</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">initialValue</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Event</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">RemoveCounter</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Event</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">IncreaseCounter</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Event</span>

<span class="k">object</span> <span class="nc">Event</span> <span class="o">{</span>
  <span class="k">import</span> <span class="nn">_root_.io.circe.Encoder</span>
  <span class="k">import</span> <span class="nn">_root_.io.circe.generic.extras.Configuration</span>
  <span class="k">import</span> <span class="nn">_root_.io.circe.generic.extras.semiauto._</span>
  <span class="k">implicit</span> <span class="k">val</span> <span class="nv">configuration</span> <span class="k">=</span> <span class="nv">Configuration</span><span class="o">.</span><span class="py">default</span><span class="o">.</span><span class="py">withDiscriminator</span><span class="o">(</span><span class="s">"type"</span><span class="o">)</span>

  <span class="k">implicit</span> <span class="k">val</span> <span class="nv">encoder</span><span class="k">:</span> <span class="kt">Encoder</span><span class="o">[</span><span class="kt">Event</span><span class="o">]</span> <span class="k">=</span> <span class="n">deriveConfiguredEncoder</span>
<span class="o">}</span>

<span class="k">val</span> <span class="nv">events</span> <span class="k">=</span> <span class="nv">Stream</span><span class="o">.</span><span class="py">emits</span><span class="o">(</span>
  <span class="nc">List</span><span class="o">[</span><span class="kt">Event</span><span class="o">](</span>
    <span class="nc">CreateCounter</span><span class="o">(</span><span class="s">"counter1"</span><span class="o">,</span> <span class="mi">0</span><span class="o">),</span>
    <span class="nc">IncreaseCounter</span><span class="o">(</span><span class="s">"counter1"</span><span class="o">),</span>
    <span class="nc">CreateCounter</span><span class="o">(</span><span class="s">"counter2"</span><span class="o">,</span> <span class="mi">0</span><span class="o">),</span>
    <span class="nc">RemoveCounter</span><span class="o">(</span><span class="s">"counter2"</span><span class="o">)</span>
  <span class="o">)</span>
<span class="o">)</span>
<span class="c1">// events: Stream[[x]Pure[x], Event] = Stream(..)</span>
</code></pre></div></div>

<p>You can generate a stream of JSON token wrapped in an object at a key named <code>events</code> like this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">fs2.data.json.circe._</span>

<span class="k">val</span> <span class="nv">wrappedTokens</span> <span class="k">=</span> <span class="nv">events</span><span class="o">.</span><span class="py">through</span><span class="o">(</span><span class="nv">ast</span><span class="o">.</span><span class="py">tokenize</span><span class="o">).</span><span class="py">through</span><span class="o">(</span><span class="nv">wrap</span><span class="o">.</span><span class="py">asArrayInObject</span><span class="o">(</span><span class="n">at</span> <span class="k">=</span> <span class="s">"events"</span><span class="o">))</span>
<span class="c1">// wrappedTokens: Stream[[x]Pure[x], Token] = Stream(..)</span>
</code></pre></div></div>

<p>You can use the renderers described above to generate the rendered chunks to send to the client.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">wrappedTokens</span><span class="o">.</span><span class="py">through</span><span class="o">(</span><span class="nv">render</span><span class="o">.</span><span class="py">compact</span><span class="o">).</span><span class="py">compile</span><span class="o">.</span><span class="py">toList</span>
<span class="c1">// res11: cats.package.Id[List[String]] = List(</span>
<span class="c1">//   "{",</span>
<span class="c1">//   "\"events\":",</span>
<span class="c1">//   "[",</span>
<span class="c1">//   "{\"name\":\"counter1\",\"initialValue\":0,\"type\":\"CreateCounter\"}",</span>
<span class="c1">//   ",{\"name\":\"counter1\",\"type\":\"IncreaseCounter\"}",</span>
<span class="c1">//   ",{\"name\":\"counter2\",\"initialValue\":0,\"type\":\"CreateCounter\"}",</span>
<span class="c1">//   ",{\"name\":\"counter2\",\"type\":\"RemoveCounter\"}",</span>
<span class="c1">//   "]",</span>
<span class="c1">//   "}"</span>
<span class="c1">// )</span>
</code></pre></div></div>

<p>You can also add other fields to the the generated object stream. For instance, letâ€™s assume we can know how big the stream will be in advance from our event store, we can send this piece of data in the first chunks, so that the client can react accordingly.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">_root_.io.circe.Json</span>

<span class="n">events</span>
  <span class="o">.</span><span class="py">through</span><span class="o">(</span><span class="nv">ast</span><span class="o">.</span><span class="py">tokenize</span><span class="o">)</span>
  <span class="o">.</span><span class="py">through</span><span class="o">(</span><span class="nv">wrap</span><span class="o">.</span><span class="py">asArrayInObject</span><span class="o">(</span><span class="n">at</span> <span class="k">=</span> <span class="s">"events"</span><span class="o">,</span> <span class="n">in</span> <span class="k">=</span> <span class="nc">Map</span><span class="o">(</span><span class="s">"size"</span> <span class="o">-&gt;</span> <span class="nv">Json</span><span class="o">.</span><span class="py">fromInt</span><span class="o">(</span><span class="mi">4</span><span class="o">))))</span>
  <span class="o">.</span><span class="py">through</span><span class="o">(</span><span class="nv">render</span><span class="o">.</span><span class="py">compact</span><span class="o">)</span>
  <span class="o">.</span><span class="py">compile</span>
  <span class="o">.</span><span class="py">toList</span>
<span class="c1">// res12: cats.package.Id[List[String]] = List(</span>
<span class="c1">//   "{",</span>
<span class="c1">//   "\"size\":4",</span>
<span class="c1">//   ",\"events\":",</span>
<span class="c1">//   "[",</span>
<span class="c1">//   "{\"name\":\"counter1\",\"initialValue\":0,\"type\":\"CreateCounter\"}",</span>
<span class="c1">//   ",{\"name\":\"counter1\",\"type\":\"IncreaseCounter\"}",</span>
<span class="c1">//   ",{\"name\":\"counter2\",\"initialValue\":0,\"type\":\"CreateCounter\"}",</span>
<span class="c1">//   ",{\"name\":\"counter2\",\"type\":\"RemoveCounter\"}",</span>
<span class="c1">//   "]",</span>
<span class="c1">//   "}"</span>
<span class="c1">// )</span>
</code></pre></div></div>

<p>For more pipes and options, please refer to the <a href="/api/fs2/data/json/package$$wrap$.html">API documentation</a>.</p>


      </div>
    </main>

    <footer class="page-footer red lighten-2">
      <div class="footer-copyright red darken-2">
        <div class="container">
          Copyright Â© 2019-2022 <a class="grey-text text-lighten-4" href="https://twitter.com/lucassatabin">@lucassatabin</a>
          <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png" class="grey-text text-lighten-4 right" /></a>
        </div>
      </div>
    </footer>

    <script type="text/javascript" src="/js/materialize.min.js"></script>
    <script type="text/javascript">
    document.addEventListener('DOMContentLoaded', function() {
      var elems = document.querySelectorAll('.sidenav');
      var instances = M.Sidenav.init(elems, {});
    });
    document.addEventListener('DOMContentLoaded', function() {
      var elems = document.querySelectorAll('.tooltipped');
      var instances = M.Tooltip.init(elems, {});
    });
    </script>
  </body>
</html>
